{"version":3,"sources":["../src/session/storage.ts","../src/session/getSessionSigner.ts","../src/session/getSessionAccount.ts","../src/common.ts","../src/getPaymaster.ts","../src/createBundlerClient.ts","../src/getBundlerTransport.ts","../src/session/getSessionClient.ts","../src/delegation/checkDelegation.ts","../src/utils/signCall.ts","../src/utils/callWithSignature.ts","../src/utils/defineCall.ts","../src/delegation/setupSession.ts","../src/EntryKit.ts","../src/validateSigner.ts","../src/formatBalance.ts","../src/debug.ts"],"names":["viem_createBundlerClient","getRecord","getAction","viem_writeContract","worldSystemsConfig"],"mappings":"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","file":"index.js","sourcesContent":["import { Address, Hex } from \"viem\";\n\ntype SessionStore = {\n  signers: Record<string, string>; // lowercase address â†’ private key\n};\n\nexport class SessionStorage {\n  private cache: SessionStore;\n  private readonly STORAGE_KEY = \"entrykit:session-signers\";\n\n  constructor() {\n    this.cache = this.load();\n  }\n\n  private load(): SessionStore {\n    if (typeof localStorage === \"undefined\") {\n      return { signers: {} };\n    }\n\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (!stored) {\n      return { signers: {} };\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch {\n      return { signers: {} };\n    }\n  }\n\n  private save(): void {\n    if (typeof localStorage === \"undefined\") return;\n    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.cache));\n  }\n\n  getSigner(address: Address): Hex | undefined {\n    const key = address.toLowerCase();\n    return this.cache.signers[key] as Hex | undefined;\n  }\n\n  setSigner(address: Address, privateKey: Hex): void {\n    const key = address.toLowerCase();\n    this.cache.signers[key] = privateKey;\n    this.save();\n  }\n\n  removeSigner(address: Address): void {\n    const key = address.toLowerCase();\n    delete this.cache.signers[key];\n    this.save();\n  }\n\n  clear(): void {\n    this.cache = { signers: {} };\n    this.save();\n  }\n}\n\nexport const sessionStorage = new SessionStorage();\n","import { Address, Hex, isHex } from \"viem\";\nimport { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { sessionStorage } from \"./storage\";\n\nexport function getSessionSigner(userAddress: Address) {\n  let privateKey = sessionStorage.getSigner(userAddress);\n\n  if (!privateKey) {\n    // Attempt to migrate from old storage keys\n    const deprecatedKey = typeof localStorage !== \"undefined\"\n      ? localStorage.getItem(`mud:appSigner:privateKey:${userAddress.toLowerCase()}`)?.replace(/^\"(.*)\"$/, \"$1\")\n      : null;\n\n    privateKey = (isHex(deprecatedKey) ? deprecatedKey : generatePrivateKey()) as Hex;\n    sessionStorage.setSigner(userAddress, privateKey);\n  }\n\n  return privateKeyToAccount(privateKey);\n}\n","import { Address, Chain, Client, LocalAccount, Transport } from \"viem\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { toSimpleSmartAccount } from \"permissionless/accounts\"\nimport { getSessionSigner } from \"./getSessionSigner\"\n\nexport type GetSessionAccountReturnType = {\n  readonly account: SmartAccount\n  readonly signer: LocalAccount\n}\n\nexport async function getSessionAccount<chain extends Chain>({\n  client,\n  userAddress\n}: {\n  client: Client<Transport, chain>\n  userAddress: Address\n}): Promise<GetSessionAccountReturnType> {\n  const signer = getSessionSigner(userAddress)\n  const account = await toSimpleSmartAccount({ client, owner: signer })\n  return { account, signer }\n}\n","import { resourceToHex } from \"@latticexyz/common\"\nimport {\n  Client,\n  Chain,\n  Transport,\n  Account,\n  parseAbi,\n  ClientConfig,\n  Address,\n  LocalAccount\n} from \"viem\"\nimport worldConfig from \"@latticexyz/world/mud.config\"\nimport { SmartAccount } from \"viem/account-abstraction\"\n\nexport type ConnectedClient<chain extends Chain = Chain> = Client<Transport, chain, Account>\nexport type SessionClient<chain extends Chain = Chain> = Client<Transport, chain, SmartAccount> & {\n  readonly userAddress: Address\n  /**\n   * World address used for delegated calls. Assumes a delegation has been set up between the user account and session account.\n   */\n  readonly worldAddress: Address\n  /** @internal */\n  readonly internal_signer: LocalAccount\n}\n\nexport const defaultClientConfig = {\n  pollingInterval: 250\n} as const satisfies Pick<ClientConfig, \"pollingInterval\">\n\n// TODO: move to world\nexport const unlimitedDelegationControlId = resourceToHex({\n  type: \"system\",\n  namespace: \"\",\n  name: \"unlimited\"\n})\n\nexport const worldTables = worldConfig.namespaces.world.tables\n\nexport const worldAbi = parseAbi([\n  \"function registerDelegation(address delegatee, bytes32 delegationControlId, bytes initCallData)\"\n])\n","import { Chain, Hex } from \"viem\"\nimport { BundlerClientConfig } from \"viem/account-abstraction\"\nimport { EntryKitConfig } from \"./config/output\"\n\nexport type Paymaster =\n  | {\n      readonly type: \"simple\"\n      readonly address: Hex\n    }\n  | {\n      readonly type: \"custom\"\n      readonly address?: Hex\n      readonly paymasterClient: BundlerClientConfig[\"paymaster\"]\n    }\n\nexport function getPaymaster(\n  chain: Chain,\n  paymasterOverride: EntryKitConfig[\"paymasterOverride\"]\n): Paymaster | undefined {\n  const contracts = chain.contracts ?? {}\n\n  if (paymasterOverride) {\n    return {\n      type: \"custom\",\n      paymasterClient: paymasterOverride\n    }\n  }\n\n  if (\"paymaster\" in contracts && contracts.paymaster != null) {\n    if (\"address\" in contracts.paymaster) {\n      return {\n        type: \"simple\",\n        address: contracts.paymaster.address\n      }\n    }\n  }\n}\n","import { Transport, Chain, Client, RpcSchema, EstimateFeesPerGasReturnType } from \"viem\"\nimport {\n  BundlerClient,\n  BundlerClientConfig,\n  SmartAccount,\n  createBundlerClient as viem_createBundlerClient\n} from \"viem/account-abstraction\"\nimport { defaultClientConfig } from \"./common\"\nimport { getPaymaster } from \"./getPaymaster\"\n\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain = Chain,\n  account extends SmartAccount = SmartAccount,\n  client extends Client = Client,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  config: BundlerClientConfig<transport, chain, account, client, rpcSchema>\n): BundlerClient<transport, chain, account, client, rpcSchema> {\n  // our generics above enforce this, but `BundlerClientConfig` makes it optional again\n  const client = config.client\n  if (!client) throw new Error(\"No `client` provided to `createBundlerClient`.\")\n\n  const chain = config.chain ?? client.chain\n  const paymaster = chain ? getPaymaster(chain, config.paymaster) : undefined\n\n  // TODO: lift this out to make `createBundlerClient` configurable?\n  return viem_createBundlerClient({\n    ...defaultClientConfig,\n    paymaster: paymaster\n      ? paymaster.type === \"custom\"\n        ? paymaster.paymasterClient\n        : {\n            getPaymasterData: async () => ({\n              paymaster: paymaster.address,\n              paymasterData: \"0x\"\n            })\n          }\n      : undefined,\n    userOperation: {\n      estimateFeesPerGas: createFeeEstimator(client)\n    },\n    ...config\n  })\n}\n\nfunction createFeeEstimator(\n  client: Client\n): undefined | (() => Promise<EstimateFeesPerGasReturnType<\"eip1559\">>) {\n  if (!client.chain) return\n\n  // anvil hardcodes fee returned by `eth_maxPriorityFeePerGas`\n  // so we override it here to mimick our chains\n  // https://github.com/foundry-rs/foundry/pull/8081#issuecomment-2402002485\n  // TODO: move this to user op executor transport?\n  if (client.chain.id === 31337) {\n    return async () => ({ maxFeePerGas: 100_000n, maxPriorityFeePerGas: 0n })\n  }\n\n  // Use viem's default fee estimation for all other chains\n  return undefined\n}\n","import { Chain, http } from \"viem\"\n\nexport function getBundlerTransport(chain: Chain) {\n  // TODO: bundler websocket\n  const bundlerHttpUrl = chain.rpcUrls.bundler?.http[0]\n  if (bundlerHttpUrl) {\n    return http(bundlerHttpUrl)\n  }\n\n  throw new Error(`Chain ${chain.id} config did not include a bundler RPC URL.`)\n}\n","import { Account, Address, Chain, Client, LocalAccount, RpcSchema, Transport } from \"viem\"\nimport { smartAccountActions } from \"permissionless\"\nimport { callFrom, sendUserOperationFrom } from \"@latticexyz/world/internal\"\nimport type { PaymasterClient } from \"viem/account-abstraction\"\nimport { createBundlerClient } from \"../createBundlerClient\"\nimport { SessionClient } from \"../common\"\nimport { SmartAccount } from \"viem/account-abstraction\"\nimport { getBundlerTransport } from \"../getBundlerTransport\"\n\nexport async function getSessionClient({\n  userAddress,\n  sessionAccount,\n  sessionSigner,\n  worldAddress,\n  paymasterOverride\n}: {\n  userAddress: Address\n  sessionAccount: SmartAccount\n  sessionSigner: LocalAccount\n  worldAddress: Address\n  paymasterOverride?: PaymasterClient\n}): Promise<SessionClient> {\n  const client = sessionAccount.client\n  if (!clientHasChain(client)) {\n    throw new Error(\"Session account client had no associated chain.\")\n  }\n\n  const bundlerClient = createBundlerClient({\n    transport: getBundlerTransport(client.chain),\n    client,\n    account: sessionAccount,\n    paymaster: paymasterOverride\n  })\n\n  const sessionClient = bundlerClient\n    .extend(smartAccountActions)\n    .extend(\n      callFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    .extend(\n      sendUserOperationFrom({\n        worldAddress,\n        delegatorAddress: userAddress,\n        publicClient: client\n      })\n    )\n    // TODO: add observer once we conditionally fetch receipts while bridge is open\n    .extend(() => ({ userAddress, worldAddress, internal_signer: sessionSigner }))\n\n  return sessionClient\n}\n\nfunction clientHasChain<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined\n>(\n  client: Client<transport, chain, account, rpcSchema>\n): client is Client<transport, Exclude<chain, undefined>, account, rpcSchema> {\n  return client.chain != null\n}\n","import { Address, Client } from \"viem\";\nimport { getRecord } from \"@latticexyz/store/internal\";\nimport { unlimitedDelegationControlId, worldTables } from \"../common\";\n\nexport type CheckDelegationParams = {\n  client: Client;\n  worldAddress: Address;\n  userAddress: Address;\n  sessionAddress: Address;\n  blockTag?: \"pending\" | \"latest\";\n};\n\nexport async function checkDelegation({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  blockTag = \"pending\",\n}: CheckDelegationParams): Promise<boolean> {\n  const record = await getRecord(client, {\n    address: worldAddress,\n    table: worldTables.UserDelegationControl,\n    key: { delegator: userAddress, delegatee: sessionAddress },\n    blockTag,\n  });\n\n  return record.delegationControlId === unlimitedDelegationControlId;\n}\n","import { Address, Chain, Client, Hex, OneOf, Transport, toHex } from \"viem\"\nimport { signTypedData } from \"viem/actions\"\nimport { callWithSignatureTypes } from \"@latticexyz/world-module-callwithsignature/internal\"\nimport { getRecord } from \"@latticexyz/store/internal\"\nimport moduleConfig from \"@latticexyz/world-module-callwithsignature/mud.config\"\nimport { hexToResource } from \"@latticexyz/common\"\nimport { getAction } from \"viem/utils\"\nimport { ConnectedClient } from \"../common\"\n\n// TODO: move this to world package or similar\n\nexport type SignCallOptions<chain extends Chain = Chain> = {\n  userClient: ConnectedClient<chain>\n  worldAddress: Address\n  systemId: Hex\n  callData: Hex\n} & OneOf<{ nonce: bigint } | { client: Client<Transport, chain> }>\n\nexport async function signCall<chain extends Chain = Chain>({\n  userClient,\n  worldAddress,\n  systemId,\n  callData,\n  nonce: initialNonce,\n  client\n}: SignCallOptions<chain>) {\n  const nonce =\n    initialNonce ??\n    (client\n      ? (\n          await getRecord(client, {\n            address: worldAddress,\n            table: moduleConfig.tables.CallWithSignatureNonces,\n            key: { signer: userClient.account.address },\n            blockTag: \"pending\"\n          })\n        ).nonce\n      : 0n)\n\n  const { namespace: systemNamespace, name: systemName } = hexToResource(systemId)\n\n  return await getAction(\n    userClient,\n    signTypedData,\n    \"signTypedData\"\n  )({\n    account: userClient.account,\n    domain: {\n      verifyingContract: worldAddress,\n      salt: toHex(userClient.chain.id, { size: 32 })\n    },\n    types: callWithSignatureTypes,\n    primaryType: \"Call\",\n    message: {\n      signer: userClient.account.address,\n      systemNamespace,\n      systemName,\n      callData,\n      nonce\n    }\n  })\n}\n","import { Chain, parseErc6492Signature } from \"viem\"\nimport { writeContract as viem_writeContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport { SignCallOptions, signCall } from \"./signCall\"\nimport CallWithSignatureAbi from \"@latticexyz/world-module-callwithsignature/out/CallWithSignatureSystem.sol/CallWithSignatureSystem.abi.json\"\nimport { ConnectedClient } from \"../common\"\n\n// TODO: move this to world package or similar\n\nexport type CallWithSignatureOptions<chain extends Chain = Chain> = SignCallOptions<chain> & {\n  sessionClient: ConnectedClient\n}\n\nexport async function callWithSignature<chain extends Chain = Chain>({\n  sessionClient,\n  ...opts\n}: CallWithSignatureOptions<chain>) {\n  const rawSignature = await signCall(opts)\n\n  // TODO: add support for ERC-6492 inside CallWithSignature module\n  const { address, signature } = parseErc6492Signature(rawSignature)\n  if (address != null) {\n    throw new Error(\n      \"ERC-6492 signatures, like from Coinbase Smart Wallet, are not yet supported. Try using a different wallet?\"\n    )\n  }\n\n  return getAction(\n    sessionClient,\n    viem_writeContract,\n    \"writeContract\"\n  )({\n    address: opts.worldAddress,\n    abi: CallWithSignatureAbi,\n    functionName: \"callWithSignature\",\n    args: [opts.userClient.account.address, opts.systemId, opts.callData, signature]\n  } as never)\n}\n","import { Address, ContractFunctionParameters, Abi } from \"viem\"\n\nexport function defineCall<abi extends Abi | readonly unknown[]>(\n  call: Omit<ContractFunctionParameters<abi>, \"address\"> & {\n    to: Address\n    value?: bigint | undefined\n  }\n) {\n  return call\n}\n","import { Hex, encodeFunctionData, zeroAddress, Client } from \"viem\"\nimport { sendUserOperation, waitForUserOperationReceipt } from \"viem/account-abstraction\"\nimport { waitForTransactionReceipt } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\"\nimport { systemsConfig as worldSystemsConfig } from \"@latticexyz/world/mud.config\"\nimport { unlimitedDelegationControlId, worldAbi, SessionClient } from \"../common\"\nimport { callWithSignature } from \"../utils/callWithSignature\"\nimport { defineCall } from \"../utils/defineCall\"\n\nexport type SetupSessionParams = {\n  client: Client\n  userClient: Client\n  sessionClient: SessionClient\n  worldAddress: Hex\n  registerDelegation?: boolean\n}\n\nexport async function setupSession({\n  client,\n  userClient,\n  sessionClient,\n  worldAddress,\n  registerDelegation = true\n}: SetupSessionParams): Promise<void> {\n  const sessionAddress = sessionClient.account.address\n\n  console.log(\"setting up session\", userClient)\n\n  if (userClient.account.type === \"smart\") {\n    // Set up session for smart account wallet\n    const calls = []\n\n    if (registerDelegation) {\n      console.log(\"registering delegation\")\n      calls.push(\n        defineCall({\n          to: worldAddress,\n          abi: worldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n        })\n      )\n    }\n\n    if (!calls.length) return\n\n    console.log(\"setting up account with\", calls, userClient)\n    const hash = await getAction(userClient, sendUserOperation, \"sendUserOperation\")({ calls })\n    console.log(\"got user op hash\", hash)\n\n    const receipt = await getAction(\n      userClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n    console.log(\"got user op receipt\", receipt)\n\n    if (!receipt.success) {\n      console.error(\"not successful?\", receipt)\n    }\n  } else {\n    // Set up session for EOAs\n    const txs: Hex[] = []\n\n    if (registerDelegation) {\n      console.log(\"registering delegation\")\n      const tx = await callWithSignature({\n        client,\n        userClient,\n        sessionClient,\n        worldAddress,\n        systemId: worldSystemsConfig.systems.RegistrationSystem.systemId,\n        callData: encodeFunctionData({\n          abi: IBaseWorldAbi,\n          functionName: \"registerDelegation\",\n          args: [sessionAddress, unlimitedDelegationControlId, \"0x\"]\n        })\n      })\n      console.log(\"got delegation tx\", tx)\n      txs.push(tx)\n    }\n\n    if (!txs.length) return\n\n    console.log(\"waiting for\", txs.length, \"receipts\")\n    for (const hash of txs) {\n      const receipt = await getAction(\n        client,\n        waitForTransactionReceipt,\n        \"waitForTransactionReceipt\"\n      )({ hash })\n      console.log(\"got tx receipt\", receipt)\n      if (receipt.status === \"reverted\") {\n        console.error(\"tx reverted?\", receipt)\n      }\n    }\n  }\n\n  // Deploy session smart account if not already deployed\n  if (!(await sessionClient.account.isDeployed?.())) {\n    console.log(\"creating session account by sending empty user op\")\n    const hash = await getAction(\n      sessionClient,\n      sendUserOperation,\n      \"sendUserOperation\"\n    )({\n      calls: [{ to: zeroAddress }]\n    })\n\n    const receipt = await getAction(\n      sessionClient,\n      waitForUserOperationReceipt,\n      \"waitForUserOperationReceipt\"\n    )({ hash })\n    console.log(\"got user op receipt\", receipt)\n  }\n}\n","import { Address, Client } from \"viem\";\nimport type { PaymasterClient } from \"viem/account-abstraction\";\nimport { SessionClient } from \"./common\";\nimport { getSessionSigner } from \"./session/getSessionSigner\";\nimport { getSessionAccount } from \"./session/getSessionAccount\";\nimport { getSessionClient } from \"./session/getSessionClient\";\nimport { checkDelegation } from \"./delegation/checkDelegation\";\nimport { setupSession } from \"./delegation/setupSession\";\nimport { sessionStorage } from \"./session/storage\";\n\nexport type EntryKitConfig = {\n  chainId: number;\n  worldAddress: Address;\n  paymasterClient?: PaymasterClient;\n};\n\nexport type EntryKitState = {\n  sessionClient: SessionClient | null;\n  userAddress: Address | null;\n  sessionAddress: Address | null;\n  isReady: boolean;\n};\n\nexport type PrerequisiteStatus = {\n  hasDelegation: boolean;\n  isReady: boolean;\n};\n\ntype StateListener = (state: EntryKitState) => void;\ntype Unsubscribe = () => void;\n\nexport class EntryKit {\n  private config: EntryKitConfig;\n  private state: EntryKitState;\n  private listeners = new Set<StateListener>();\n\n  constructor(config: EntryKitConfig) {\n    this.config = config;\n    this.state = {\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false,\n    };\n  }\n\n  // ===== Reactive State Management =====\n\n  /**\n   * Subscribe to state changes\n   * Returns unsubscribe function\n   */\n  subscribe(listener: StateListener): Unsubscribe {\n    this.listeners.add(listener);\n    listener(this.state); // Immediate callback with current state\n    return () => this.listeners.delete(listener);\n  }\n\n  /**\n   * Get current state (non-reactive)\n   */\n  getState(): EntryKitState {\n    return { ...this.state };\n  }\n\n  private updateState(updates: Partial<EntryKitState>): void {\n    this.state = { ...this.state, ...updates };\n    this.notify();\n  }\n\n  private notify(): void {\n    this.listeners.forEach((listener) => listener(this.state));\n  }\n\n  // ===== Core API =====\n\n  /**\n   * Connect with user's wallet client\n   * Creates session account and session client\n   */\n  async connect(userClient: Client): Promise<void> {\n    if (!userClient.account) {\n      throw new Error(\"Wallet client must have an account.\");\n    }\n    if (!userClient.chain) {\n      throw new Error(\"Wallet client must have a chain.\");\n    }\n\n    const userAddress = userClient.account.address;\n\n    // Get or create session signer\n    const signer = getSessionSigner(userAddress);\n\n    // Create session smart account\n    const { account } = await getSessionAccount({\n      client: userClient as any,\n      userAddress,\n    });\n\n    // Create session client with MUD extensions\n    const sessionClient = await getSessionClient({\n      userAddress,\n      sessionAccount: account,\n      sessionSigner: signer,\n      worldAddress: this.config.worldAddress,\n      paymasterOverride: this.config.paymasterClient,\n    });\n\n    this.updateState({\n      sessionClient,\n      userAddress,\n      sessionAddress: account.address,\n    });\n\n    // Check if delegation already exists\n    await this.checkPrerequisites();\n  }\n\n  /**\n   * Check if session is ready to use\n   * Returns delegation status\n   */\n  async checkPrerequisites(): Promise<PrerequisiteStatus> {\n    if (!this.state.sessionClient) {\n      return { hasDelegation: false, isReady: false };\n    }\n\n    const hasDelegation = await checkDelegation({\n      client: this.state.sessionClient,\n      worldAddress: this.config.worldAddress,\n      userAddress: this.state.userAddress!,\n      sessionAddress: this.state.sessionAddress!,\n    });\n\n    this.updateState({ isReady: hasDelegation });\n\n    return { hasDelegation, isReady: hasDelegation };\n  }\n\n  /**\n   * Setup session (register delegation, deploy account)\n   */\n  async setupSession(userClient: Client): Promise<void> {\n    if (!this.state.sessionClient) {\n      throw new Error(\"Not connected. Call connect() first.\");\n    }\n\n    await setupSession({\n      client: userClient,\n      userClient,\n      sessionClient: this.state.sessionClient,\n      worldAddress: this.config.worldAddress,\n    });\n\n    this.updateState({ isReady: true });\n  }\n\n  /**\n   * Disconnect and clear session\n   */\n  disconnect(): void {\n    this.updateState({\n      sessionClient: null,\n      userAddress: null,\n      sessionAddress: null,\n      isReady: false,\n    });\n  }\n\n  /**\n   * Clear stored session keys\n   */\n  clearStorage(): void {\n    if (this.state.userAddress) {\n      sessionStorage.removeSigner(this.state.userAddress);\n    }\n  }\n\n  // ===== Convenience Getters =====\n\n  get sessionClient(): SessionClient | null {\n    return this.state.sessionClient;\n  }\n\n  get userAddress(): Address | null {\n    return this.state.userAddress;\n  }\n\n  get sessionAddress(): Address | null {\n    return this.state.sessionAddress;\n  }\n\n  get isReady(): boolean {\n    return this.state.isReady;\n  }\n}\n","import { Address, Client } from \"viem\"\nimport { readContract } from \"viem/actions\"\nimport { checkDelegation } from \"./delegation/checkDelegation\"\n\n/**\n * @internal\n */\nexport async function internal_validateSigner({\n  client,\n  worldAddress,\n  userAddress,\n  sessionAddress,\n  signerAddress\n}: {\n  client: Client\n  worldAddress: Address\n  userAddress: Address\n  sessionAddress: Address\n  signerAddress: Address\n}) {\n  const ownerAddress = await readContract(client, {\n    address: sessionAddress,\n    abi: simpleAccountAbi,\n    functionName: \"owner\"\n  })\n\n  if (ownerAddress.toLowerCase() !== signerAddress.toLowerCase()) {\n    throw new Error(\n      `Session account owner (${ownerAddress}) does not match message signer (${signerAddress}).`\n    )\n  }\n\n  const hasDelegation = await checkDelegation({\n    client,\n    worldAddress,\n    sessionAddress,\n    userAddress,\n    blockTag: \"latest\"\n  })\n\n  if (!hasDelegation) {\n    throw new Error(\n      `Session account (${sessionAddress}) does not have delegation for user account (${userAddress}).`\n    )\n  }\n}\n\n// TODO: import ABI once we can get strongly typed JSON or expose `getOwner` or similar method on smart account\nconst simpleAccountAbi = [\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const\n","import { formatEther } from \"viem\"\n\nexport function formatBalance(wei: bigint) {\n  // TODO: should this support non-ether decimals?\n  const formatted = formatEther(wei)\n  const parsed = parseFloat(formatted)\n\n  if (parsed > 0 && parsed < 0.00001) {\n    return \"<0.00001\"\n  }\n\n  const magnitude = Math.floor(parsed).toString().length\n  return parsed.toLocaleString(\"en-US\", { maximumFractionDigits: Math.max(0, 6 - magnitude) })\n}\n","import createDebug from \"debug\"\n\nexport const debug = createDebug(\"mud:entrykit\")\nexport const error = createDebug(\"mud:entrykit\")\n\n// Pipe debug output to stdout instead of stderr\ndebug.log = console.debug.bind(console)\n\n// Pipe error output to stderr\nerror.log = console.error.bind(console)\n"]}